# Tutorial: Saving and loading your plug-in state

Automatic management of your plug-in parameters. Storing and accessing parameters becomes a breeze and, in particular, makes building effective user interfaces much easier.

**LEVEL:** Intermediate<br/>
**PLATFORMS:** Windows, macOS, Linux<br/>
**CLASSES:** [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state."), [ValueTree](https://docs.juce.com/master/classValueTree.html "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ..."), [XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")

# Getting started

Download the demo project for this tutorial here: [PIP](https://docs.juce.com/tutorials/PIPs/AudioProcessorValueTreeStateTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/AudioProcessorValueTreeStateTutorial.zip) . Unzip the project and open the first header file in the Projucer.

If you need help with this step, see [Tutorial: Projucer Part 1: Getting started with the Projucer](/tutorials/tutorial_new_projucer_project/).

You should also know how to build an audio plug-in using JUCE and load this into your preferred audio host (such as a Digital Audio Workstation). See [Tutorial: Create a basic Audio/MIDI plugin, Part 1: Setting up](/tutorials/tutorial_create_projucer_basic_plugin/) for an introduction. Ideally, you should also have read [Tutorial: Adding plug-in parameters](/tutorials/tutorial_audio_parameter/), as an introduction to audio processor parameters.

# The demo project

The demo project is loosely based on the _GainPlugin_ project in the `JUCE/examples/Plugins` directory. This plugin changes the gain of an incoming signal using a single parameter. In addition to this, it also has a phase invert\* parameter to invert the phase of the incoming signal.

# The gain processor

Most of the code in the `TutorialProcessor` class is the same as that generated by the Projucer when you use the **Audio Plug-In** project template. For simplicity, we have bundled the processor code into a single `.h` file rather than being split across a `.cpp` and an `.h` file. The editor for the processor is in the `GenericEditor` class.

There are several advantages to using the [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class for managing your plug-in's parameters:

- The [ValueTree](https://docs.juce.com/master/classValueTree.html "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") class inherently provides undo support.
- [ValueTree](https://docs.juce.com/master/classValueTree.html "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") objects already have support for serialising and deserialising (to XML).
- [ValueTree](https://docs.juce.com/master/classValueTree.html "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") objects can have listeners attached to them. This means that the [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class can almost automatically connect to sliders and buttons to keep the state of the UI and the processor up-to-date in a thread safe manner.

To use an [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object, you can store one in your processor class:

```cpp
private:
//==============================================================================
juce::AudioProcessorValueTreeState parameters;
```

You may store your [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object elsewhere but you must be careful that each [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object must be:

- attached to only one processor; and
- have the same lifetime as the processor (as they will have dependencies on each other).

Storing the [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object in the processor class makes it easier to ensure that you satisfy these requirements.

The [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") constructor requires a reference to the [AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.") subclass that it will be attached to, a pointer to an [UndoManager](https://docs.juce.com/master/classUndoManager.html "Manages a list of undo/redo commands.") object, an [Identifier](https://docs.juce.com/master/classIdentifier.html "Represents a string identifier, designed for accessing properties by name.") for the [ValueTree](https://docs.juce.com/master/classValueTree.html "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") and an [AudioProcessorValueTreeState::ParameterLayout](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ParameterLayout.html "A class to contain a set of RangedAudioParameters and AudioProcessorParameterGroups containing Ranged...") containing the parameters to manage.

```cpp
AudioProcessorValueTreeState (AudioProcessor& processorToConnectTo,
    UndoManager* undoManagerToUse,
    const juce::Identifier& valueTreeType,
    ParameterLayout parameterLayout);
```

In this case, we will use a `nullptr` value for the [UndoManager](https://docs.juce.com/master/classUndoManager.html "Manages a list of undo/redo commands.") object as we\'re not going to implement undo support in this tutorial. The `nullptr` value indicates that we do not want to use undo support.

## Configuring the parameters

The [AudioProcessorValueTreeState::ParameterLayout](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ParameterLayout.html "A class to contain a set of RangedAudioParameters and AudioProcessorParameterGroups containing Ranged...") parameter of the [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") contains the parameters of our plug-in. The [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") can manage any parameters derived from [RangedAudioParameter](https://docs.juce.com/master/classRangedAudioParameter.html "This abstract base class is used by some AudioProcessorParameter helper classes."), and the [AudioProcessorValueTreeState::ParameterLayout](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ParameterLayout.html "A class to contain a set of RangedAudioParameters and AudioProcessorParameterGroups containing Ranged...") constructor can take a variable number of [RangedAudioParameter](https://docs.juce.com/master/classRangedAudioParameter.html "This abstract base class is used by some AudioProcessorParameter helper classes.") subclasses or AudioProcessorParameterGroups containing RangedAudioParameters.

Parameters and groups are passed using std::unique_ptr as the APVTS will take ownership of the parameters and groups.

JUCE's built-in parameter types, the same ones we used in [Tutorial: Adding plug-in parameters](/tutorials/tutorial_audio_parameter/), are subclasses of [RangedAudioParameter](https://docs.juce.com/master/classRangedAudioParameter.html "This abstract base class is used by some AudioProcessorParameter helper classes."), so we can use them here too.

```cpp
TutorialProcessor()
    : parameters (*this, nullptr, juce::Identifier ("APVTSTutorial"),
          {
              std::make_unique<juce::AudioParameterFloat> ("gain", // parameterID
                  "Gain", // parameter name
                  0.0f, // minimum value
                  1.0f, // maximum value
                  0.5f), // default value
              std::make_unique<juce::AudioParameterBool> ("invertPhase", // parameterID
                  "Invert Phase", // parameter name
                  false) // default value
          })
{
```

Adding your parameters to an [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") automatically adds them to the attached [AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.") too.

The _parameter ID_ should be a unique identifier for this parameter. Think of this like a variable name; it can contain alphanumeric characters and underscores, but no spaces. The _parameter name_ is the name that will be displayed on the screen.

## Performing the gain processing

To help avoid clicks in the signal, we smooth gain changes and changes in signal phase. To do this, we store the previously calculated gain value in our processor [1]:

```cpp
private:
//==============================================================================
juce::AudioProcessorValueTreeState parameters;
float previousGain; // [1]

std::atomic<float>* phaseParameter = nullptr;
std::atomic<float>* gainParameter = nullptr;

//==============================================================================
JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TutorialProcessor)
};
```

We also store pointers to our parameters at the end of our constructor to dereference them later on:

```cpp
phaseParameter = parameters.getRawParameterValue ("invertPhase");
gainParameter = parameters.getRawParameterValue ("gain");
```

The changes are initialised in the `TutorialProcessor::prepareToPlay()` function:

```cpp
void prepareToPlay (double, int) override
{
    auto phase = *phaseParameter < 0.5f ? 1.0f : -1.0f;
    previousGain = *gainParameter * phase;
}
```

Here we calculate the phase inversion factor (+1 or -1) and multiply this by the gain, ready for the first processing callback. You can see that we use the [AudioProcessorValueTreeState::getRawParameterValue()](https://docs.juce.com/master/classAudioProcessorValueTreeState.html#a645123ccd146258f28d77b6095169c91 "Returns a pointer to a floating point representation of a particular parameter which a realtime proce...") function to get a pointer to the `float` value representing the parameter value. We dereference this to get the actual value. The processing is performed in the `TutorialProcessor::processBlock()` function:

```cpp
void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override
{
    auto phase = *phaseParameter < 0.5f ? 1.0f : -1.0f;
    auto currentGain = *gainParameter * phase;

    if (juce::approximatelyEqual (currentGain, previousGain))
    {
        buffer.applyGain (currentGain);
    }
    else
    {
        buffer.applyGainRamp (0, buffer.getNumSamples(), previousGain, currentGain);
        previousGain = currentGain;
    }
}
```

Here you can see that if the value hasn\'t changed, then we simply apply a constant gain. If the value has changed, then we apply the gain ramp, then update the `previousGain` value for next time.

## Storing and retrieving parameters

In addition to providing routines for processing audio you also need to provide methods for storing and retrieving the _entire_ state of your plug-in into a block of memory. This should include the current values of all of your parameters, but it can also include other state information if needed (for example, if your plug-in deals with files, it might store the file paths).

Using an [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object to store your plug-in's state makes this really simple as a [ValueTree](https://docs.juce.com/master/classValueTree.html "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") object can easily be converted to and from XML.

The [AudioProcessor::getStateInformation()](https://docs.juce.com/master/classAudioProcessor.html#a5d79591b367a7c0516e4ef4d1d6c32b2 "The host will call this method when it wants to save the processor's internal state.") callback asks your plug-in to store its state into a [MemoryBlock](https://docs.juce.com/master/classMemoryBlock.html "A class to hold a resizable block of raw data.") object. To do this using XML via the [ValueTree](https://docs.juce.com/master/classValueTree.html "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") object the code is simply:

```cpp
void getStateInformation (juce::MemoryBlock& destData) override
{
    auto state = parameters.copyState();
    std::unique_ptr<juce::XmlElement> xml (state.createXml());
    copyXmlToBinary (*xml, destData);
}
```

The [XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.") object created will have a _tag name_ of \"APVTSTutorial\", which we used to initialise the [ValueTree](https://docs.juce.com/master/classValueTree.html "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") object earlier.

Restoring the state from XML is almost as straightforward:

```cpp
void setStateInformation (const void* data, int sizeInBytes) override
{
    std::unique_ptr<juce::XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));

    if (xmlState.get() != nullptr)
        if (xmlState->hasTagName (parameters.state.getType()))
            parameters.replaceState (juce::ValueTree::fromXml (*xmlState));
}
```

Here we include some error checking for safety. We also check that the ValueTree-generated XML is of the correct [ValueTree](https://docs.juce.com/master/classValueTree.html "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") _type_ for our plug-in by inspecting the XML element's _tag name_.

# The gain editor

Take a look at the `GenericEditor` class in the project. You might notice that the declaration of the `GenericEditor` class is very simple:

```cpp
class GenericEditor : public juce::AudioProcessorEditor
{
public:
```

You might expect that we would need to inherit from the [Slider::Listener](https://docs.juce.com/master/classSlider.html#a1977aeac9b4363e8ed0cac0ac103055a) class and the [Button::Listener](https://docs.juce.com/master/classButton_1_1Listener.html "Used to receive callbacks when a button is clicked.") class in order to respond to slider and button interaction. But this is again one of the benefits of using the [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class. Instead we can use the _attachment_ classes within the [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class.

## Component attachments

In fact, as the names of these classes can become very long, we have included a `typedef` for each of the attachment classes we need:

```cpp
typedef juce::AudioProcessorValueTreeState::SliderAttachment SliderAttachment;
typedef juce::AudioProcessorValueTreeState::ButtonAttachment ButtonAttachment;
```

Our `GenericEditor` class contains a number of members, including a slider, a toggle button, and some of these attachment objects:

```cpp
private:
    juce::AudioProcessorValueTreeState& valueTreeState;

    juce::Label gainLabel;
    juce::Slider gainSlider;
    std::unique_ptr<SliderAttachment> gainAttachment;

    juce::ToggleButton invertButton;
    std::unique_ptr<ButtonAttachment> invertAttachment;
};
```

We also need to refer to the [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object so we also keep a reference to that.

The constructor for our `GenericEditor` class sets up these objects:

```cpp
GenericEditor (juce::AudioProcessor& parent, juce::AudioProcessorValueTreeState& vts)
    : AudioProcessorEditor (parent),
      valueTreeState (vts)
{
    gainLabel.setText ("Gain", juce::dontSendNotification);
    addAndMakeVisible (gainLabel);

    addAndMakeVisible (gainSlider);
    gainAttachment.reset (new SliderAttachment (valueTreeState, "gain", gainSlider));

    invertButton.setButtonText ("Invert Phase");
    addAndMakeVisible (invertButton);
    invertAttachment.reset (new ButtonAttachment (valueTreeState, "invertPhase", invertButton));

    setSize (paramSliderWidth + paramLabelWidth, juce::jmax (100, paramControlHeight * 2));
}
```

This is called by our processor's `TutorialProcessor::createEditor()` function:

```cpp
juce::AudioProcessorEditor* createEditor() override { return new GenericEditor (*this, parameters); }
```

You may notice that we don\'t even need to set up the slider's value range. This is done automatically by the [SliderAttachment](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1SliderAttachment.html) class. All we need to do is pass the _attachment_ constructor the [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state."), the _parameter ID_ and the [Slider](https://docs.juce.com/master/classSlider.html "A slider control for changing a value.") object that it should attach to.

> [!TIP]
>We still retain ownership of the [Slider](https://docs.juce.com/master/classSlider.html "A slider control for changing a value.") object. You should ensure that the *attachment* class has the same lifetime as the [Slider](https://docs.juce.com/master/classSlider.html "A slider control for changing a value.") object.

The [ButtonAttachment](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ButtonAttachment.html) class still requires us to provide the button name. (And the [AudioProcessorValueTreeState::ComboBoxAttachment](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ComboBoxAttachment.html "An object of this class maintains a connection between a ComboBox and a parameter in an AudioProcesso...") class, which can attach to a [ComboBox](https://docs.juce.com/master/classComboBox.html "A component that lets the user choose from a drop-down list of choices.") object, requires us to populate the [ComboBox](https://docs.juce.com/master/classComboBox.html "A component that lets the user choose from a drop-down list of choices.") manually.)

> [!NOTE]
> Exercise: Change the plug-in to support only a 2-channel main bus and add a channel swap parameter that can optionally swap the left and right channels. - Again using a 2-channel only plug-in, add a balance parameter to balance the left and right channel levels.

# Adding Parameters Programatically

You can also add parameters (or AudioProcessorParameterGroups) to an [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") programatically, by calling `add` on it. An example of how to do this is shown below:

```cpp
juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
{
    juce::AudioProcessorValueTreeState::ParameterLayout params;

    for (int i = 1; i < 9; ++i)
        params.add (std::make_unique<AudioParameterInt> (String (i), String (i), 0, i, 0));

    return params;
}

YourAudioProcessor()
    : parameters (*this, nullptr, "PARAMETERS", createParameterLayout())
{
    //...
```

# Deprecated Methods

Before JUCE version 5.4 the only way to add parameters to an [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") was to use the now deprecated createAndAddParameter method with many function parameters.

Code that previously looked like

```cpp
createAndAddParameter (paramID1, paramName1, ...);
```

can be re-written as

```cpp
using Parameter = juce::AudioProcessorValueTreeState::Parameter;
createAndAddParameter (std::make_unique<Parameter> (paramID1, paramName1, ...));
```

but using the new [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") constructor described in this tutorial is a much better approach:

```cpp
using Parameter = AudioProcessorValueTreeState::Parameter;
YourAudioProcessor()
    : apvts (*this, nullptr, "PARAMETERS", { std::make_unique<Parameter> (paramID1, paramName1, ...), std::make_unique<Parameter> (paramID2, paramName2, ...), ... })
```

# Summary

In this tutorial we have introduced the [AudioProcessorValueTreeState](https://docs.juce.com/master/classAudioProcessorValueTreeState.html "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class and shown how it can help you to:

- Manage your plug-in parameters.
- Store and retrieve your plug-in state using XML.
- Connect your plug-in parameters to buttons and sliders in a threadsafe manner.

# See also

- [Tutorial: Adding plug-in parameters](/tutorials/tutorial_audio_parameter/)
- [Tutorial: Configuring the right bus layouts for your plugins](/tutorials/tutorial_audio_bus_layouts/)
- [Tutorial: The ValueTree class](/tutorials/tutorial_value_tree/)
- [Tutorial: Cascading plug-in effects](/tutorials/tutorial_audio_processor_graph/)
